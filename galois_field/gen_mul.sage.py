

# This file was *autogenerated* from the file /home/ruben/src/classic-mceliece-hw-redo/src/common/galois_field/gen_mul.sage
from sage.all_cmdline import *   # import sage library

_sage_const_13 = Integer(13); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_16 = Integer(16)#
# Copyright (C) 2018
# Function: generate the module for finite field elements multiplication.
# Authors: Wen Wang <wen.wang.ww349@yale.edu>
#          Ruben Niederhagen <ruben@polycephaly.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse

parser = argparse.ArgumentParser(description='Generate GF(m) multiplier module.',
                formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-m','--gf', dest='gf', type=int, default=_sage_const_13 ,
          help='field 2^m')
args = parser.parse_args()


gf = args.gf

F = GF(_sage_const_2 )['x']; (x,) = F._first_ngens(1)
K = GF(_sage_const_2 **gf, modulus="first_lexicographic", names=('a',)); (a,) = K._first_ngens(1)

def set_red(f, g):
  diff = len(f) - g[_sage_const_0 ] - _sage_const_1 

  while diff >= _sage_const_0 :
    s = f[-_sage_const_1 ]

    for i in g:
      f[diff + i] = s.symmetric_difference(f[diff + i])

    while len(f[-_sage_const_1 ]) == _sage_const_0 :
      del f[-_sage_const_1 ]

    diff = len(f) - g[_sage_const_0 ] - _sage_const_1 

  return f

#print(f'Modulus: {K.modulus()}')

f = []

for i in range(gf*_sage_const_2 ):
  f.append(set([i]))

f_red = set_red(f, K.modulus().exponents()[::-_sage_const_1 ])



mul = []
for i in range(gf*_sage_const_2 ):
  mul.append([])

for i in range(gf):
  for j in range(gf):
    mul[i+j].append("dinA[{0}]*dinB[{1}]".format(i,j))


fin = []
for i in range(gf):
  fin.append([])

for i, l in enumerate(f_red):
  for j in l:
    fin[i] += mul[j]


# verify
for i in range(_sage_const_16 ):
  ge = K.random_element()
  he = K.random_element()

  dinA = ge.polynomial()
  dinB = he.polynomial()
  
  tmp = _sage_const_0 
  
  for i, t in enumerate(fin):
    for j in t:
      tmp += x**i * eval(j)

  assert sage_eval(str(tmp), locals={'x':a}) == (ge*he)


print("""module gf_mul (
  input            clk,
  input  [{0} : 0] dinA,
  input  [{0} : 0] dinB,
  output [{0} : 0] dout
);\n""".format(gf-_sage_const_1 ))

for i, l in enumerate(fin):
  print("  assign dout[{0}] = ".format(i) + " ^ ".join([t.replace("*", "&") for t in l]) + ";")

print("\nendmodule")


